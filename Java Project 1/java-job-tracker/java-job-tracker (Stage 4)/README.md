# Job Application Tracker (Stage 4 — Desktop UI + SQLite Persistence)

Stage 4 upgrades the Job Application Tracker into a **local-first desktop application** backed by **SQLite** (replacing CSV as the primary data store).

- **Stage 1:** Console app (OOP + layered design)
- **Stage 2:** CSV persistence (data survives restarts)
- **Stage 3:** Swing desktop UI + Load/Save CSV
- **Stage 4 (this folder):** Swing desktop UI + **SQLite persistence** (JDBC)

---

## What Stage 4 adds

### SQLite persistence (JDBC)
- Data is stored in a local SQLite database file:
  - **Default path:** `~/.jobtracker/job_tracker.db`
- The app initializes the schema automatically on startup.
- IDs are generated by SQLite (`INTEGER PRIMARY KEY AUTOINCREMENT`).

### UI (personal-use friendly)
- Table view of applications
- Add / update status / delete
- Filter by status
- Optional CSV import/export (if enabled in your UI) for portability/backup

---

## Tech stack
- Java 17+ (tested on 17/21)
- Maven
- Swing (desktop UI)
- SQLite (via `org.xerial:sqlite-jdbc`)
- JDBC

---

## Project structure (typical)

```
src/main/java/com/johndoan/jobtracker/
  UiMain.java                      # Stage 4 UI entry point
  Main.java                        # Stage 1 console entry point (optional/legacy)
  JobApplication.java              # domain model
  ApplicationStatus.java           # enum
  ApplicationService.java          # business logic
  ApplicationRepository.java       # repository interface

src/main/java/com/johndoan/jobtracker/persistence/
  Database.java                    # connection + schema init
  JdbcApplicationRepository.java   # SQLite-backed repository

src/main/java/com/johndoan/jobtracker/ui/
  JobTrackerFrame.java             # Swing UI

src/main/resources/
  schema.sql                       # SQLite schema (loaded by Database.init)
```

---

## Database schema and table name

In Stage 4, the table name is:

- **`applications`** (not `job_applications`)

Example schema:

```sql
CREATE TABLE IF NOT EXISTS applications (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  company TEXT NOT NULL,
  position TEXT NOT NULL,
  location TEXT NOT NULL,
  status TEXT NOT NULL,
  date_applied TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_applications_status
ON applications(status);
```

---

## How to run (Stage 4)

### Option A (recommended): Run in IntelliJ IDEA
1. Open the Stage 4 folder as a Maven project.
2. Ensure Maven dependencies are imported (you should see `sqlite-jdbc` under Maven).
3. Run:
- `com.johndoan.jobtracker.UiMain`

Expected behavior:
- App starts and creates `~/.jobtracker/job_tracker.db` if missing.
- Add/update/delete rows — they persist after closing/reopening.

### Option B: Build with Maven, then run
Build:

```bash
mvn clean package
```

If your `pom.xml` is configured with Maven Shade Plugin (fat jar), run the jar that Maven produced:

```bash
ls -la target
# Then run the jar name you actually see in target/
java -jar target/<jar-name>.jar
```

If you get “Unable to access jarfile …”, it usually means the filename is different than expected—`ls target` is the quickest fix.

---

## How to view the SQL table (3 ways)

### 1) Terminal: `sqlite3` (fastest)
Open the DB:

```bash
sqlite3 ~/.jobtracker/job_tracker.db
```

Then run:

```sql
.tables
.schema applications
SELECT COUNT(*) FROM applications;
SELECT * FROM applications ORDER BY id DESC LIMIT 20;
.quit
```

### 2) IntelliJ IDEA: Database tool window (visual)
If you have IntelliJ IDEA Ultimate or DataGrip features enabled:

1. Open **View → Tool Windows → Database**.
2. Click **+** → **Data Source** → **SQLite**.
3. Set **Database file** to:
- `~/.jobtracker/job_tracker.db`
4. Click **Test Connection**, then **OK**.
5. Expand the schema → table **applications**.
6. Right-click **applications** → **Jump to Data** (or “Edit Data”) to browse rows.

Tip: If IntelliJ says “No data sources are configured…”, you just need to add the SQLite data source as above.

### 3) From inside the app (the UI itself)
If the UI is wired to SQLite for Stage 4, then:
- Launch the app → click **Refresh** (or similar) → the table should reflect what’s in SQLite.
- Add a record → close app → reopen → record should still be there.

---

## About the ID values (why they may not start at 1)

SQLite `AUTOINCREMENT` does **not** automatically reset back to 1 after deletes. It keeps increasing to avoid reusing old IDs.

If you want to reset IDs during development/demo:
- Easiest: delete the database file (this deletes all data):
  ```bash
  rm ~/.jobtracker/job_tracker.db
  ```
  Then re-run the app to recreate it.

Or, inside `sqlite3` (advanced; use with care):
```sql
DELETE FROM applications;
DELETE FROM sqlite_sequence WHERE name='applications';
```


---

## Build artifacts / dist folder (optional)

This stage is a desktop app that you typically run from IntelliJ. If you want a simple “dist” folder for sharing/running locally, you can copy the built UI jar there.

### 1) Build the UI jar
```bash
mvn clean package
```

Confirm the jar name:
```bash
ls -la target | grep -E "ui\.jar$"
```

### 2) Create `dist/` and copy the UI jar
```bash
mkdir -p dist
cp target/*-ui.jar dist/
```

Run it:
```bash
java -jar dist/*-ui.jar
```

### 3) (Optional) macOS .dmg via `jpackage`
If you have `jpackage` available (`jpackage --version`), you can bundle a DMG.

```bash
APP_NAME="JobTracker"
VERSION="2.0.0"
JAR_NAME="$(ls -1 target/*-ui.jar | head -n 1 | xargs -n 1 basename)"

mkdir -p dist
cp "target/$JAR_NAME" dist/

jpackage   --type dmg   --name "$APP_NAME"   --app-version "$VERSION"   --input dist   --main-jar "$JAR_NAME"   --dest dist
```

Output:
- `dist/JobTracker-<version>.dmg` (name varies by macOS/jpackage)

Notes:
- If the app launches but can’t find the SQLite driver, you’re not using the fat “ui” jar. Always package/run the `*-ui.jar`.
- If you change the app name/version, re-run `mvn clean package` before re-packaging.


---

## Common troubleshooting

### `java.sql.SQLException: No suitable driver found for jdbc:sqlite:...`
This means the SQLite JDBC driver is **not on your runtime classpath**.

Fix options:
- Run from IntelliJ (it includes Maven dependencies automatically), or
- Run the **shaded/fat jar** built by Maven Shade Plugin, or
- Manually add the `sqlite-jdbc-*.jar` to your `-cp` runtime classpath.

### SLF4J warning:
```
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
```
Harmless (no logging backend configured). You can ignore it.

### “No such table …”
Stage 4 table name is **`applications`**. Use:
```sql
SELECT * FROM applications;
```

---

## Notes on CSV files in Stage 4

Stage 4’s source of truth is SQLite.

- Multiple CSV files are fine—they **do not affect** SQLite unless you explicitly import them.
- If the UI still shows a CSV path field, treat it as optional **import/export**:
  - **Import** loads rows into SQLite
  - **Export** writes rows out for backup/portability

If you want Stage 4 to be “DB-only,” you can hide/disable the CSV controls in the UI.

---
